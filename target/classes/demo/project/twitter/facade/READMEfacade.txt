1. Под каждую Entity создан проводник контроллер-фасад-сервис.

2. Service - класс, в котором создаются методы Entity (доступ к данным из БД, какая-то иная логика)

3. Facade - класс, который связывает контролле и сервис. По сути - в его методах весь функционал, необходимый для
обработки request и формировании response. Основан на функионале, заложенном в Service

4. Контроллер - обрабатывает запросы и отправляет их на обработку в Facade
#
При формировании данного шлюза контроллер-фасад-сервис НАЧИНАТЬ НУЖНО С ИНТЕРФЕЙСА Functional, где необходимо
 заявить все методы для Service.

 Потом Repo - не торогаем. Repo имплементить CrudRepository. Соответсвенно, методы для работы с Entity берутся оттуда.
 Но это - не принципиально. Можете подключить любой, какой хотите.

 Потом Service - описываем методы, заявленные в интерфейсе Functional. Можно без интерфейса, но типа не красиво, принцип
 SOLID будет под угрозой.

 Потом Facade - по сути создаем логику обработки запросов. В данном слое подключается библиотека ModelMapper. Она
 настроена минимальным образом. Нужна для быстрой передачи данных полей одного класса в другой. Без создания геттеров,
 сеттеров и прочей суеты. В данном случае - мы используем маппер для передачи данных из объекта Entity в объект Dto.
 И в обратном направлении.
 Именно объект Dto будет передаваться и приниматься на фронт.

 Потом Dto - это объект-соответствие объекта Entity, создаваемый для работы с фронтом. Здесь нужно прописать именно
 те поля Entity, которые нужны для фронта. ВАЖНО, что бы полностью совпадали назавние поля и тип поля. Поля могут быть
 не все из тех, которые есть у Entity. Порядок объявления полей тоже не имеет значения.

 Ну и последний - контроллер. Нужно прописать путь для Entity в аннотации @RequestMapping. Ну и больше ничего
 интересного.

 В каждом классе прописаны примеры того, как это должно быть. Это - именно примеры для понимания. Их можно снести, но
 писать свое - по принципу и подобию. Особенно с точки зрения соблюдения иерархии структуры контроллер-фасад-сервис.